"""
control.py

Generate feedforward control inputs (steering, acceleration) for a simple
bicycle model from a time-parameterized trajectory.

Assumes trajectory array with columns:
[t, x_ref, y_ref, heading_ref, s_ref, v_ref]

Outputs:
    U: ndarray (N,2) with columns [theta, a]
"""

import os
import numpy as np
import math
import pandas as pd

CAR_LENGTH = 20.0  # meters, adjust as needed


class State:
    def __init__(self, x, y, v, phi):
        self.x = x
        self.y = y
        self.v = v
        self.phi = phi

    def __getitem__(self, key):
        return (self.x, self.y, self.v, self.phi)[key]

    def copy(self):
        return State(self.x, self.y, self.v, self.phi)


def control_input(state: State, U, dt=0.1):
    """
    Simple bicycle model update for one timestep.

    U = [theta, a] steering (rad), acceleration (m/s^2)
    """
    theta, a = U
    v_dot = a
    v = state.v + v_dot * dt
    phi_dot = state.v * math.tan(theta) / CAR_LENGTH
    phi = state.phi + phi_dot * dt
    x = state.x + v * -math.sin(phi) * dt
    y = state.y + v * math.cos(phi) * dt
    return State(x, y, v, phi)


def trajectory_to_controls(traj: np.ndarray, car_length: float = CAR_LENGTH, plot: bool = False):
    """
    Convert a time-parameterized trajectory to feedforward control inputs [theta, a].

    Inputs:
        traj: (N,6) array with columns [t, x_ref, y_ref, heading_ref, s_ref, v_ref]
        car_length: length of vehicle for bicycle model
        plot: if True, plot the resulting steering & acceleration profiles

    Returns:
        U: (N,2) array of [theta, a] per timestep
    """
    t = traj[:, 0]
    phi_ref = traj[:, 3]
    v_ref = traj[:, 5]

    dt = np.gradient(t)
    dt[dt < 1e-6] = 1e-6  # avoid divide by zero

    # 1. Acceleration
    a = np.gradient(v_ref, t)

    # 2. Heading derivative
    phi_dot = np.gradient(phi_ref, t)

    # 3. Steering angle (bicycle model)
    theta = np.arctan2(phi_dot * car_length, np.maximum(v_ref, 1e-3))  # avoid divide by zero

    # Combine into control array
    U = np.vstack([theta, a]).T

    # Optional plotting
    if plot:
        import matplotlib.pyplot as plt
        fig, axes = plt.subplots(2, 1, figsize=(8, 6))
        axes[0].plot(t, theta, '-')
        axes[0].set_ylabel('Steering θ (rad)')
        axes[0].set_xlabel('Time (s)')
        axes[0].grid(True)
        axes[0].set_title('Steering Profile')

        axes[1].plot(t, a, '-')
        axes[1].set_ylabel('Acceleration a (m/s²)')
        axes[1].set_xlabel('Time (s)')
        axes[1].grid(True)
        axes[1].set_title('Acceleration Profile')

        plt.tight_layout()
        plt.show()

    return U


def simulate_trajectory(traj: np.ndarray, U: np.ndarray, dt: float = 0.02):
    """
    Run the simple bicycle model forward using the computed control inputs.
    Returns a list of State objects.
    """
    states = []
    state = State(traj[0, 1], traj[0, 2], traj[0, 5], traj[0, 3])
    states.append(state.copy())
    for i in range(len(U)):
        print("Turning angle:", math.degrees(U[i][0]))
        print("Prev heading:", math.degrees(state[3]))
        state = control_input(state, U[i], dt)
        print("New heading:", math.degrees(state[3]))
        print()
        states.append(state.copy())
    return states


def load_traj_from_csv(filename: str) -> np.ndarray:
    """
    Load a trajectory CSV generated by save_traj_to_csv.
    Expects columns: t, x_ref, y_ref, heading_ref, s_ref, v_ref (others optional)
    """
    if not os.path.exists(filename):
        raise FileNotFoundError(f"{filename} does not exist.")
    df = pd.read_csv(filename)
    required_cols = ['t', 'x_ref', 'y_ref', 'heading_ref', 's_ref', 'v_ref']
    for col in required_cols:
        if col not in df.columns:
            raise ValueError(f"Column '{col}' not found in CSV.")
    return df[required_cols].to_numpy()


# ---- Example usage ----
if __name__ == "__main__":
    # Load trajectory CSV
    try:
        traj = load_traj_from_csv("traj.csv")
        U = trajectory_to_controls(traj, plot=True)

        # simulate forward
        states = simulate_trajectory(traj, U, dt=np.mean(np.gradient(traj[:, 0])))
        xs = [s.x for s in states]
        ys = [s.y for s in states]

        import matplotlib.pyplot as plt
        plt.figure()
        plt.plot(traj[:, 1], traj[:, 2], 'r--', label='Reference Path')
        plt.plot(xs, ys, 'b-', label='Simulated Path')
        plt.axis('equal')
        plt.xlabel('x (m)')
        plt.ylabel('y (m)')
        plt.title('Trajectory Simulation with Feedforward Controls')
        plt.legend()
        plt.show()

    except FileNotFoundError:
        print("No traj.csv found; this is just a template usage example.")
